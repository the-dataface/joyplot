<!DOCTYPE html>
<html>
<head>
<link href="https://fonts.googleapis.com/css?family=Mada:300,500,700" rel="stylesheet">
<style>

svg {
    display: block;
    margin: 0 auto;
    font-family: 'Mada';
    font-weight: 300;
}

.axis .domain {
    display: none;
}

.axis--x text, .axis--y text{
    fill: #999;
}

.axis--x line {
    stroke: #777;
    stroke-width: .1;
}

.axis--name .tick line {
    display: none;
}

.axis--name .tick text {
    font-size: 14px;
    fill: #000;
}

.axis--name .tick text:hover {
    font-size: 20px;
    fill: #000;
    text-decoration: underline;
    text-decoration-color: #448cab;
}

.line {
    fill: none;
    stroke: #fff;
}

.name:nth-child(odd) .line{
    fill: none;
}

.area {
    fill: #448cab;
}

.name:nth-child(odd) .area {
  fill: #5ca3c1;
}
.overlay {
  fill: none;
  pointer-events: all;
}

.focus circle {
  fill: none;
  stroke: grey;
}

.bolded-text#mentions{
  font-weight: 700;
  font-size: 20px;
  baseline-shift: -44%;
}

.bolded-text#date{
  font-weight: 700;
  font-size: 20px;
  baseline-shift: -21%;
}

.sub-text {
  font-weight: 300;
  baseline-shift: sub;
}
.meme-container {
  width:10px;
  height:10px;
}
.annotation text {
  fill: black;
}
.axis--name .tick:hover {
  cursor:pointer;
  background-color:grey;
}

.tick {
  background-color:grey;
}
.change-data-button {
  width:10px;
  height:10px
}


</style>
</head>
<body>
  <span class="change-data-button">hey<span>
  <div class="joyplot-container"></div>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="d3-annotation.min.js"></script>
<script>
//good colors - #448cab and #5ca3c1

var margin = { top: 100, right: 200, bottom: 300, left: 300 },
    width = 1200 - margin.left - margin.right,
    height = 5000 - margin.top - margin.bottom;

// Percent two area charts can overlap
var overlap = .5;

//create svg with margins
var svg = d3.select('.joyplot-container')
            .append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

var x = function(d) { return d.date; };
var xScale = d3.scaleTime().range([0, width]);
var xValue = function(d) { return xScale(x(d)); };
var xAxis = d3.axisBottom(xScale).tickFormat(d3.timeFormat("%b")).tickArguments([d3.timeMonth.every(1)]);

var y = function(d) { return d.mentions; };
var yScale = d3.scaleLinear();
var yValue = function(d) { return yScale(y(d)); };

var nameCalc = function(d) { return d.key; };
var nameScale = d3.scaleBand().range([0, height]);
var nameValue = function(d) { return nameScale(nameCalc(d)); };
var nameAxis = d3.axisLeft(nameScale);

var meanCalc = function(d) {return d.mean; };

var area = d3.area()
             .curve(d3.curveMonotoneX)
             .x(xValue)
             .y1(yValue);

var line = area.lineY1();

var parseTime = d3.timeParse("%m/%d/%Y");
var timeFormat = d3.timeFormat("%B %e");
var bisectDate = d3.bisector(function(d) { return d}).left;

var cleanString = function(string) {
  return string.replace(/[^A-Z0-9]+/ig, "_");
}

var rowConverter = function(d) {
    return {
        name: d.meme,
        date: parseTime(d.date),
        mentions: +d.index,
        benchmarked_mentions: +d.benchmarked_index
    };
}

var benchmarked = true;

d3.csv('meme_interest_data_stacked.csv', rowConverter, function(error, dataset) {
    if (error) throw error;

    // Sort by time
    dataset.sort(function(a, b) { return a.date - b.date; });

    var data = d3.nest()
        .key(function(d) { return d.name; })
        .entries(dataset);

    function findPeaks(d) {
        for (i in d) {
          var topic_values = d[i].values;
          var max_index = d3.scan(topic_values, function(a, b) {return y(b) - y(a)});
          var peakTime = x(topic_values[max_index]);
          var peakMentions = y(topic_values[max_index]);
          d[i].peakTime = peakTime;
          d[i].peakMentions = peakMentions;
        }
    };
    findPeaks(data);

    data.sort(function(a, b) { return a.peakTime - b.peakTime;});

    xScale.domain(d3.extent(dataset, x));
    nameScale.domain(data.map(function(d) { return d.key; }));

    var areaChartHeight = (1 + overlap) * (height / nameScale.domain().length);

    yScale.domain([0, d3.max(dataset, function(d) {
            return d.mentions;
          })])
          .range([areaChartHeight, 0]);

    area.y0(yScale(0));

    var xAxisTransform = height + (overlap * (height / nameScale.domain().length));
    var xAxis2Transform = 0;
    //height / nameScale.domain().length;
    var yAxisTransform = overlap * (height / nameScale.domain().length);

    var gName = svg.append('g')
            .attr('class', 'names')
            .selectAll('.name')
            .data(data)
            .enter()
            .append('g')
            .attr('class', function(d) { return 'name--' + cleanString(d.key); })
            .attr('transform', function(d) {
                var ty = nameValue(d);
                return 'translate(0,' + ty + ')';
            });

    gName.append('path')
        .attr('class', 'area')
        .datum(function(d) { return d.values; })
        .attr('d', area);

    gName.append('path')
        .attr('class', 'line')
        .datum(function(d) { return d.values; })
        .attr('d', line);

    var mouseover = function(index) {
      var name, peakTime, peakMentions;
      name = data[index].key;
      peakTime = data[index].peakTime;
      peakMentions = data[index].peakMentions;

      console.log(peakMentions);
      console.log(peakTime);

      const type = d3.annotationCallout;

      const annotations = [{
        note: {
          label: "during the week of " + timeFormat(peakTime),
          title: "Index of " + peakMentions
        },
        //can use x, y directly instead of data
        data: { date: peakTime, mentions: peakMentions},
        dy: -25,
        dx: 25
      }];

      const makeAnnotations = d3.annotation()
        .type(type)
        //accessors & accessorsInverse not needed
        //if using x, y in annotations JSON
        .accessors({
          x: d => xScale(d.date),
          y: d => yScale(d.mentions)
        })
        .accessorsInverse({
           date: d => xScale.invert(d.x),
           close: d => yScale.invert(d.y)
        })
        .annotations(annotations);

      var nameNoSpace = cleanString(name);

      d3.select("g.name--" + nameNoSpace)
        .append("g")
        .attr("class", "annotation-group")
        .call(makeAnnotations);

    }

    svg.append('g')
       .attr('class', 'axis axis--x')
       .attr('transform', 'translate(0,' + xAxisTransform + ')')
       .call(xAxis);

    svg.append('g')
       .attr('class', 'axis axis--x2')
       .attr('transform', 'translate(0,' + xAxis2Transform + ')')
       .call(xAxis);

    svg.append('g')
       .attr('class', 'axis axis--name')
       .attr('transform', 'translate(0,' + yAxisTransform + ')')
       .call(nameAxis);

    d3.select(".change-data-button")
      .on("click", function() {
        changeData();
      });

    d3.select(".axis--name")
      .selectAll(".tick")
      .on("mouseover", function(d, i) {

          d3.select("g.names")
            .selectAll("g")
            .attr("opacity", ".1")
            .filter(function() {
               var className = "name--" + cleanString(d);
               if (d3.select(this).attr("class") == className) {
                  return true;
               } else {
                  return false;
               }
             })
             .attr("opacity", "1")

           d3.select("g.axis--name")
             .selectAll("g.tick")
             .attr("opacity", "1")
             .filter(function() {
                if (d3.select(this).text() == d) {
                   return false;
                } else {
                   return true;
                }
              })
              .attr("opacity", ".1");

            mouseover(i);

      })
      .on("mouseout", function() {
          d3.selectAll(".annotation-group").remove();

          d3.select("g.axis--name")
            .selectAll("g.tick")
            .attr("opacity", "1");

          d3.select("g.names")
            .selectAll("g")
            .attr("opacity", "1");
      });

    var changeData = function() {
      if (benchmarked) {
        y = function(d) { return d.benchmarked_mentions; };
        yScale.domain([0, d3.max(dataset, function(d) {
                return d.benchmarked_mentions;
              })])
        benchmarked = false;
      } else {
        y = function(d) { return d.mentions; };
        yScale.domain([0, d3.max(dataset, function(d) {
                return d.mentions;
              })])
        benchmarked = true;
      }

      function findPeaks(d) {
          for (i in d) {
            var topic_values = d[i].values;
            var max_index = d3.scan(topic_values, function(a, b) {return y(b) - y(a)});
            var peakTime = x(topic_values[max_index]);
            var peakMentions = y(topic_values[max_index]);
            d[i].peakTime = peakTime;
            d[i].peakMentions = peakMentions;
          }
      };
      findPeaks(data);

      xScale.domain(d3.extent(dataset, x));
      nameScale.domain(data.map(function(d) { return d.key; }));

      var areaChartHeight = (1 + overlap) * (height / nameScale.domain().length);


      area.y0(yScale(0));

      gName.select('path.area')
           .datum(function(d) { return d.values; })
           .transition()
           .duration(1200)
           .attr('d', area);

      gName.select('path.line')
           .datum(function(d) { return d.values; })
           .transition()
           .duration(1200)
           .attr('d', line);

    }


});

</script>
</body>
</html>
